[{
        "pointer": "/linear/solver",
        "default": "",
        "type": "string",
        "doc": "Linear solver type.",
        "options": [
            "Eigen::SimplicialLDLT",
            "Eigen::SparseLU",
            "Eigen::CholmodSupernodalLLT",
            "Eigen::UmfPackLU",
            "Eigen::SuperLU",
            "Eigen::PardisoLDLT",
            "Eigen::PardisoLLT",
            "Eigen::PardisoLU",
            "Pardiso",
            "Hypre",
            "AMGCL",
            "Eigen::LeastSquaresConjugateGradient",
            "Eigen::DGMRES",
            "Eigen::ConjugateGradient",
            "Eigen::BiCGSTAB",
            "Eigen::GMRES",
            "Eigen::MINRES"
        ]
    },
    {
        "pointer": "/linear/precond",
        "default": "",
        "type": "string",
        "doc": "Preconditioner used if using an iterative linear solver.",
        "options": [
            "Eigen::IdentityPreconditioner",
            "Eigen::DiagonalPreconditioner",
            "Eigen::IncompleteCholesky",
            "Eigen::LeastSquareDiagonalPreconditioner",
            "Eigen::IncompleteLUT"
        ]
    },
    {
        "pointer": "/linear/Eigen::LeastSquaresConjugateGradient",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's Least Squares Conjugate Gradient solver."
    },
    {
        "pointer": "/linear/Eigen::DGMRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's DGMRES solver."
    },
    {
        "pointer": "/linear/Eigen::ConjugateGradient",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's Conjugate Gradient solver."
    },
    {
        "pointer": "/linear/Eigen::BiCGSTAB",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's BiCGSTAB solver."
    },
    {
        "pointer": "/linear/Eigen::GMRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's GMRES solver."
    },
    {
        "pointer": "/linear/Eigen::MINRES",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Eigen's MINRES solver."
    },
    {
        "pointer": "/linear/Pardiso",
        "default": null,
        "type": "object",
        "optional": [
            "mtype"
        ],
        "doc": "Settings for the Pardiso solver."
    },
    {
        "pointer": "/linear/Hypre",
        "default": null,
        "type": "object",
        "optional": [
            "max_iter",
            "pre_max_iter",
            "tolerance"
        ],
        "doc": "Settings for the Hypre solver."
    },
    {
        "pointer": "/linear/AMGCL",
        "default": null,
        "type": "object",
        "optional": [
            "solver",
            "precond"
        ],
        "doc": "Settings for the AMGCL solver."
    },
    {
        "pointer": "/linear/Eigen::LeastSquaresConjugateGradient/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/Eigen::LeastSquaresConjugateGradient/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/Eigen::DGMRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/Eigen::DGMRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/Eigen::ConjugateGradient/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/Eigen::ConjugateGradient/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/Eigen::BiCGSTAB/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/Eigen::BiCGSTAB/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/Eigen::GMRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/Eigen::GMRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/Eigen::MINRES/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/Eigen::MINRES/tolerance",
        "default": 1e-12,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/Pardiso/mtype",
        "default": 11,
        "type": "int",
        "options": [
            1,
            2,
            -2,
            3,
            4,
            -4,
            6,
            11,
            13
        ],
        "doc": "Matrix type."
    },
    {
        "pointer": "/linear/Hypre/max_iter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/Hypre/pre_max_iter",
        "default": 1,
        "type": "int",
        "doc": "Maximum number of pre iterations."
    },
    {
        "pointer": "/linear/Hypre/tolerance",
        "default": 1e-10,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/AMGCL/solver",
        "default": null,
        "type": "object",
        "optional": [
            "tol",
            "maxiter",
            "type"
        ],
        "doc": "Solver settings for the AMGCL."
    },
    {
        "pointer": "/linear/AMGCL/precond",
        "default": null,
        "type": "object",
        "optional": [
            "relax",
            "class",
            "max_levels",
            "direct_coarse",
            "ncycle",
            "coarsening"
        ],
        "doc": "Preconditioner settings for the AMGCL."
    },
    {
        "pointer": "/linear/AMGCL/solver/maxiter",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations."
    },
    {
        "pointer": "/linear/AMGCL/solver/tol",
        "default": 1e-10,
        "type": "float",
        "doc": "Convergence tolerance."
    },
    {
        "pointer": "/linear/AMGCL/solver/type",
        "default": "cg",
        "type": "string",
        "doc": "Type of solver to use."
    },
    {
        "pointer": "/linear/AMGCL/precond/relax",
        "default": null,
        "type": "object",
        "optional": [
            "degree",
            "type",
            "power_iters",
            "higher",
            "lower",
            "scale"
        ],
        "doc": "Preconditioner settings for the AMGCL."
    },
    {
        "pointer": "/linear/AMGCL/precond/class",
        "default": "amg",
        "type": "string",
        "doc": "Type of preconditioner to use."
    },
    {
        "pointer": "/linear/AMGCL/precond/max_levels",
        "default": 6,
        "type": "int",
        "doc": "Maximum number of levels."
    },
    {
        "pointer": "/linear/AMGCL/precond/direct_coarse",
        "default": false,
        "type": "bool",
        "doc": "Use direct solver for the coarsest level."
    },
    {
        "pointer": "/linear/AMGCL/precond/ncycle",
        "default": 2,
        "type": "int",
        "doc": "Number of cycles."
    },
    {
        "pointer": "/linear/AMGCL/precond/coarsening",
        "default": null,
        "type": "object",
        "optional": [
            "type",
            "estimate_spectral_radius",
            "relax",
            "aggr"
        ],
        "doc": "Coarsening parameters."
    },
    {
        "pointer": "/linear/AMGCL/precond/relax/degree",
        "default": 16,
        "type": "int",
        "doc": "Degree of the polynomial."
    },
    {
        "pointer": "/linear/AMGCL/precond/relax/type",
        "default": "chebyshev",
        "type": "string",
        "doc": "Type of relaxation to use."
    },
    {
        "pointer": "/linear/AMGCL/precond/relax/power_iters",
        "default": 100,
        "type": "int",
        "doc": "Number of power iterations."
    },
    {
        "pointer": "/linear/AMGCL/precond/relax/higher",
        "default": 2,
        "type": "float",
        "doc": "Higher level relaxation."
    },
    {
        "pointer": "/linear/AMGCL/precond/relax/lower",
        "default": 0.008333333333,
        "type": "float",
        "doc": "Lower level relaxation."
    },
    {
        "pointer": "/linear/AMGCL/precond/relax/scale",
        "default": true,
        "type": "bool",
        "doc": "Scale."
    },
    {
        "pointer": "/linear/AMGCL/precond/coarsening/type",
        "default": "smoothed_aggregation",
        "type": "string",
        "doc": "Coarsening type."
    },
    {
        "pointer": "/linear/AMGCL/precond/coarsening/estimate_spectral_radius",
        "default": true,
        "type": "bool",
        "doc": "Should the spectral radius be estimated."
    },
    {
        "pointer": "/linear/AMGCL/precond/coarsening/relax",
        "default": 1,
        "type": "float",
        "doc": "Coarsening relaxation."
    },
    {
        "pointer": "/linear/AMGCL/precond/coarsening/aggr",
        "default": null,
        "type": "object",
        "optional": [
            "eps_strong"
        ],
        "doc": "Aggregation settings."
    },
    {
        "pointer": "/linear/AMGCL/precond/coarsening/aggr/eps_strong",
        "default": 0,
        "type": "float",
        "doc": "Aggregation epsilon strong."
    },
    {
        "pointer": "/nonlinear",
        "default": null,
        "type": "object",
        "optional": [
            "solver",
            "f_delta",
            "x_delta",
            "grad_norm",
            "first_grad_norm_tol",
            "max_iterations",
            "relative_gradient",
            "line_search",
            "force_psd_projection",
            "allow_out_of_iterations"
        ],
        "doc": "Settings for nonlinear solver. Interior-loop linear solver settings are defined in the solver/linear section."
    },
    {
        "pointer": "/nonlinear/solver",
        "default": "newton",
        "type": "string",
        "options": [
            "newton",
            "gradient_descent",
            "lbfgs"
        ],
        "doc": "Nonlinear solver type"
    },
    {
        "pointer": "/nonlinear/f_delta",
        "default": 1e-10,
        "type": "float",
        "min": 0,
        "doc": "Stopping criterion: minimal change of the energy f for the iterations to continue."
    },
    {
        "pointer": "/nonlinear/x_delta",
        "default": 0,
        "type": "float",
        "min": 0,
        "doc": "Stopping criterion: minimal change of the variables x for the iterations to continue. Computed as the L2 norm of x divide by the time step."
    },
    {
        "pointer": "/nonlinear/grad_norm",
        "default": 1e-08,
        "type": "float",
        "min": 0,
        "doc": "Stopping criterion: Minimal gradient norm for the iterations to continue."
    },
    {
        "pointer": "/nonlinear/first_grad_norm_tol",
        "default": 1e-10,
        "type": "float",
        "doc": "Minimal gradient norm for the iterations to not start, assume we already are at a minimum."
    },
    {
        "pointer": "/nonlinear/max_iterations",
        "default": 1000,
        "type": "int",
        "doc": "Maximum number of iterations for a nonlinear solve."
    },
    {
        "pointer": "/nonlinear/relative_gradient",
        "default": false,
        "type": "bool",
        "doc": "If true, use relative gradient norm threshold, use absolute otherwise"
    },
    {
        "pointer": "/nonlinear/line_search",
        "default": null,
        "type": "object",
        "optional": [
            "method",
            "use_grad_norm_tol"
        ],
        "doc": "Settings for line-search in the nonlinear solver"
    },
    {
        "pointer": "/nonlinear/line_search/method",
        "default": "backtracking",
        "type": "string",
        "options": [
            "armijo",
            "armijo_alt",
            "backtracking",
            "more_thuente",
            "none"
        ],
        "doc": "Line-search type"
    },
    {
        "pointer": "/nonlinear/line_search/use_grad_norm_tol",
        "default": 0.0001,
        "type": "float",
        "doc": "When the energy is smaller than use_grad_norm_tol, line-search uses norm of gradient instead of energy"
    },
    {
        "pointer": "/nonlinear/force_psd_projection",
        "default": false,
        "type": "bool",
        "doc": "Force the Hessian to be PSD when using second order solvers (i.e., Newton's method)."
    },
    {
        "pointer": "/nonlinear/allow_out_of_iterations",
        "default": false,
        "type": "bool",
        "doc": "If false (default), an exception will be thrown when the nonlinear solver reaches the maximum number of iterations."
    }
]