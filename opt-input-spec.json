[
    {
        "pointer": "/",
        "type": "object",
        "required": [
            "parameters",
            "variable_to_simulation",
            "functionals",
            "states"
        ],
        "optional": [
            "output",
            "solver"
        ],
        "doc": "Root of the configuration file."
    },
    {
        "pointer": "/states",
        "type": "list",
        "doc": "TODO"
    },
    {
        "pointer": "/states/*",
        "type": "object",
        "required": [
            "path"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/states/*/path",
        "type": "file",
        "doc": "TODO"
    },
    {
        "pointer": "/output",
        "default": null,
        "type": "object",
        "optional": [
            "solve_log_level",
            "save_frequency"
        ],
        "doc": "Optimization output options"
    },
    {
        "pointer": "/output/save_frequency",
        "default": 1,
        "type": "int",
        "doc": "Optimization output frequency"
    },
    {
        "pointer": "/output/solve_log_level",
        "default": 2,
        "type": "int",
        "doc": "Log level in forward solve"
    },
    {
        "pointer": "/solver",
        "type": "object",
        "default": null,
        "optional": [
            "nonlinear"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/solver/nonlinear",
        "default": null,
        "type": "object",
        "optional": [
            "solver",
            "bounds",
            "f_delta",
            "debug_fd",
            "debug_fd_eps",
            "max_step_size",
            "max_change",
            "better_initial_guess",
            "x_delta",
            "solver_info_log",
            "grad_norm",
            "max_iterations",
            "min_step_size",
            "use_grad_norm",
            "relative_gradient",
            "line_search",
            "export_energy",
            "export_energy_components",
            "first_grad_norm_tol"
        ],
        "doc": "Settings for optimization nonlinear solver. Interior-loop linear solver settings are defined in the solver/linear section"
    },
    {
        "pointer": "/solver/nonlinear/solver",
        "default": "lbfgs",
        "type": "string",
        "options": [
            "mma",
            "lbfgs",
            "bfgs",
            "lbfgsb",
            "gradientdescent"
        ],
        "doc": "Nonlinear solver type"
    },
    {
        "pointer": "/solver/nonlinear/bounds",
        "type": "file",
        "extensions": [
            ".txt"
        ],
        "doc": "Box constraints in the optimizations specified in a txt file"
    },
    {
        "pointer": "/solver/nonlinear/bounds",
        "type": "list",
        "default": [
            0,
            0
        ],
        "doc": "Box constraints in the optimizations specified in an array of size 2"
    },
    {
        "pointer": "/solver/nonlinear/bounds/*",
        "type": "float",
        "doc": "Box constraint values"
    },
    {
        "pointer": "/solver/nonlinear/export_energy_components",
        "default": false,
        "type": "bool",
        "doc": "Save energy and gradient components"
    },
    {
        "pointer": "/solver/nonlinear/export_energy",
        "default": "runtime.csv",
        "type": "string",
        "doc": "Save energy and gradient in optimizations to file"
    },
    {
        "pointer": "/solver/nonlinear/debug_fd",
        "default": false,
        "type": "bool",
        "doc": "Use finite difference to verify gradient in optimization"
    },
    {
        "pointer": "/solver/nonlinear/debug_fd_eps",
        "default": 1e-7,
        "type": "float",
        "doc": "Use finite difference to verify gradient in optimization"
    },
    {
        "pointer": "/solver/nonlinear/max_change",
        "default": 1e10,
        "type": "float",
        "doc": "Max difference in design variables in single iteration"
    },
    {
        "pointer": "/solver/nonlinear/max_step_size",
        "default": 1,
        "type": "float",
        "doc": "Max step size in line search"
    },
    {
        "pointer": "/solver/nonlinear/better_initial_guess",
        "default": false,
        "type": "bool",
        "doc": "Use former solves as the initial guess in line search iterations"
    },
    {
        "pointer": "/solver/nonlinear/f_delta",
        "default": 1e-10,
        "type": "float",
        "doc": "Stopping criterion: minimal change of the energy f for the iterations to continue"
    },
    {
        "pointer": "/solver/nonlinear/x_delta",
        "default": 0,
        "type": "float",
        "doc": "Stopping criterion: minimal change of the variable x for the iterations to continue"
    },
    {
        "pointer": "/solver/nonlinear/solver_info_log",
        "default": true,
        "type": "bool",
        "doc": "Print optimization nonlinear solver statistics to log in json format at every iter"
    },
    {
        "pointer": "/solver/nonlinear/grad_norm",
        "default": 1e-08,
        "type": "float",
        "doc": "Stopping criterion: Minimal gradient norm for the iterations to continue"
    },
    {
        "pointer": "/solver/nonlinear/first_grad_norm_tol",
        "default": 1e-8,
        "type": "float",
        "doc": "Minimal gradient norm for the iterations to not start, assume we already are at a minimum."
    },
    {
        "pointer": "/solver/nonlinear/min_step_size",
        "default": 0,
        "type": "float",
        "doc": "Minimum step size in line search"
    },
    {
        "pointer": "/solver/nonlinear/max_iterations",
        "default": 200,
        "type": "int",
        "doc": "Maximum number of iterations for a non-linear solve."
    },
    {
        "pointer": "/solver/nonlinear/use_grad_norm",
        "default": true,
        "type": "bool",
        "doc": "If true, enable gradient-norm stopping criterion, absolute (if relative_gradient is false), or relative to the initial gradient magnitude before the first iteration, otherwise."
    },
    {
        "pointer": "/solver/nonlinear/relative_gradient",
        "default": false,
        "type": "bool",
        "doc": "If true, use relative gradient norm threshold, use absolute otherwise"
    },
    {
        "pointer": "/solver/nonlinear/line_search",
        "default": null,
        "type": "object",
        "optional": [
            "method",
            "use_grad_norm_tol"
        ],
        "doc": "Settings for line-search in the nonlinear solver"
    },
    {
        "pointer": "/solver/nonlinear/line_search/method",
        "default": "backtracking",
        "type": "string",
        "options": [
            "armijo",
            "backtracking"
        ],
        "doc": "Line-search type"
    },
    {
        "pointer": "/solver/nonlinear/line_search/use_grad_norm_tol",
        "default": 0,
        "type": "float",
        "doc": "When the energy is smaller than use_grad_norm_tol, line-search uses norm of gradient instead of energy"
    },
    {
        "pointer": "/variable_to_simulation",
        "type": "list",
        "doc": "TODO"
    },
    {
        "pointer": "/variable_to_simulation/*/type",
        "type": "string",
        "options": [
            "shape",
            "elastic",
            "friction",
            "damping",
            "macro-strain",
            "initial",
            "sdf-shape",
            "dirichlet"
        ]
    },
    {
        "pointer": "/variable_to_simulation/*",
        "type_name": "shape",
        "type": "object",
        "required": [
            "state",
            "type",
            "composition"
        ],
        "optional": [
            "composite_map_type"
        ]
    },
    {
        "pointer": "/variable_to_simulation/*",
        "type_name": "elastic",
        "type": "object",
        "required": [
            "state",
            "type",
            "composition"
        ],
        "optional": [
            "composite_map_type"
        ]
    },
    {
        "pointer": "/variable_to_simulation/*",
        "type_name": "sdf-shape",
        "type": "object",
        "required": [
            "mesh",
            "mesh_id",
            "state",
            "type",
            "composition"
        ],
        "optional": [
            "composite_map_type"
        ]
    },
    {
        "pointer": "/variable_to_simulation/*/mesh",
        "type": "string"
    },
    {
        "pointer": "/variable_to_simulation/*/mesh_id",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/state",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/state",
        "type": "list"
    },
    {
        "pointer": "/variable_to_simulation/*/state/*",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/composition",
        "type": "list",
        "doc": "list of parametrizations that maps raw optimization variables to parameters in simulations"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/type",
        "type": "string",
        "options": [
            "per-body-to-per-elem",
            "E-nu-to-lambda-mu",
            "slice",
            "exp",
            "scale",
            "power",
            "append-values",
            "append-const",
            "linear-filter",
            "custom-symmetric",
            "sdf-to-mesh",
            "periodic-mesh-tile",
            "mesh-affine",
            "bounded-biharmonic-weights"
        ]
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "bounded-biharmonic-weights",
        "type": "object",
        "required": [
            "num_control_vertices",
            "num_vertices"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "append-const",
        "type": "object",
        "required": [
            "value",
            "size"
        ],
        "doc": "Append repeated constant at the end of the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/size",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/value",
        "type": "float"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "append-values",
        "type": "object",
        "required": [
            "values"
        ],
        "doc": "Append a list of constants at the end of the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/values",
        "type": "list"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/values/*",
        "type": "float"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "slice",
        "type": "object",
        "required": [
            "from",
            "to"
        ],
        "optional": [
            "last"
        ],
        "doc": "Ouputs x[from:to], where x is the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/from",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/to",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/last",
        "type": "int",
        "default": -1
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "power",
        "type": "object",
        "required": [
            "power"
        ],
        "doc": "Ouputs x ^ power, where x is the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/power",
        "type": "float"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "scale",
        "type": "object",
        "required": [
            "value"
        ],
        "doc": "Ouputs x * value, where x is the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "mesh-affine",
        "type": "object",
        "required": [
            "input_path",
            "output_path",
            "dimension"
        ],
        "optional": [
            "transformation"
        ],
        "doc": "Append a list of constants at the end of the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/dimension",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation",
        "type": "object",
        "default": null,
        "optional": [
            "translation",
            "rotation",
            "rotation_mode",
            "scale",
            "dimensions"
        ]
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/rotation_mode",
        "type": "string",
        "default": "xyz",
        "doc": "Type of rotation, supported are any permutation of [xyz]+, axis_angle, quaternion, or rotation_vector."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/translation",
        "type": "list",
        "default": [],
        "doc": "Translate (two entries for 2D problems or three entries for 3D problems)."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/rotation",
        "type": "list",
        "default": [],
        "doc": "Rotate, in 2D, one number, the rotation angle, in 3D, three or four Euler angles, axis+angle, or a unit quaternion. Depends on rotation mode."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/scale",
        "type": "list",
        "default": [],
        "doc": "Scale by specified factors along axes (two entries for 2D problems or three entries for 3D problems)."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/dimensions",
        "type": "float",
        "default": 1,
        "doc": "Scale the object so that bounding box dimensions match specified dimensions, 2 entries for 2D problems, 3 entries for 3D problems."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/dimensions",
        "type": "list",
        "doc": "Scale the object so that bounding box dimensions match specified dimensions, 2 entries for 2D problems, 3 entries for 3D problems."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/dimensions/*",
        "type": "float",
        "default": 0
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/translation/*",
        "type": "float",
        "default": 0
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/rotation/*",
        "default": 0,
        "type": "float"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/transformation/scale/*",
        "default": 0,
        "type": "float"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "periodic-mesh-tile",
        "type": "object",
        "required": [
            "input_path",
            "output_path",
            "dimensions"
        ],
        "doc": "Append a list of constants at the end of the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/dimensions",
        "type": "list"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/dimensions/*",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "per-body-to-per-elem",
        "type": "object",
        "required": [
            "state"
        ],
        "doc": "From per volume selection to per element."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "E-nu-to-lambda-mu",
        "type": "object",
        "required": [
            "is_volume"
        ]
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/is_volume",
        "type": "bool"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "linear-filter",
        "type": "object",
        "required": [
            "state",
            "radius"
        ],
        "doc": "Apply linear smoothing filter on a field per element."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "custom-symmetric",
        "type": "object",
        "optional": [
            "fixed_entries",
            "equal_pairs",
            "sum_equal_pairs"
        ],
        "doc": "To set equality constraint."
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/fixed_entries",
        "type": "list",
        "default": []
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/equal_pairs",
        "type": "list",
        "default": []
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/sum_equal_pairs",
        "type": "list",
        "default": []
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/state",
        "type": "int"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/radius",
        "type": "float"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*",
        "type_name": "sdf-to-mesh",
        "type": "object",
        "required": [
            "wire_path",
            "output_path"
        ],
        "optional": [
            "options",
            "use_volume_velocity"
        ],
        "doc": "Append a list of constants at the end of the input vector"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/use_volume_velocity",
        "type": "bool",
        "default": false
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/wire_path",
        "type": "string"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/input_path",
        "type": "string"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/output_path",
        "type": "string"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/options",
        "type": "object",
        "optional": [
            "maxArea",
            "dump_shape_velocity",
            "marchingSquaresGridSize",
            "forceMSGridSize"
        ],
        "default": null
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/options/maxArea",
        "type": "float",
        "default": 1e-3
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/options/dump_shape_velocity",
        "type": "string",
        "default": "velocity.msh"
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/options/marchingSquaresGridSize",
        "type": "int",
        "default": 256
    },
    {
        "pointer": "/variable_to_simulation/*/composition/*/options/forceMSGridSize",
        "type": "bool",
        "default": false
    },
    {
        "pointer": "/variable_to_simulation/*/composite_map_type",
        "type": "string",
        "default": "none"
    },
    {
        "pointer": "/parameters",
        "type": "list",
        "doc": "TODO"
    },
    {
        "pointer": "/parameters/*",
        "type": "object",
        "required": [
            "number"
        ],
        "optional": [
            "initial",
            "bounds"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/parameters/*/initial",
        "type": "list",
        "default": []
    },
    {
        "pointer": "/parameters/*/initial/*",
        "type": "float"
    },
    {
        "pointer": "/parameters/*/bounds",
        "type": "list",
        "default": []
    },
    {
        "pointer": "/parameters/*/bounds/*",
        "type": "list",
        "doc": "In the form of [[min1, min2, ...], [max1, max2, ...]]"
    },
    {
        "pointer": "/parameters/*/bounds/*/*",
        "type": "float"
    },
    {
        "pointer": "/parameters/*/bounds/*",
        "type": "float",
        "doc": "In the form of [min, max]"
    },
    {
        "pointer": "/parameters/*/bounds",
        "type": "file",
        "doc": "N by 2 matrix stored in file"
    },
    {
        "pointer": "/parameters/*/number",
        "type": "int"
    },
    {
        "pointer": "/parameters/*/number",
        "type": "object",
        "doc": "Define number of DOFs from existing DOFs in simulations"
    },
    {
        "pointer": "/parameters/*/number/state",
        "type": "int"
    },
    {
        "pointer": "/parameters/*/number/type",
        "type": "string",
        "options": [
            "per-vertex",
            "per-element"
        ]
    },
    {
        "pointer": "/functionals",
        "type": "list",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/type",
        "type": "string",
        "options": [
            "transient_integral",
            "power",
            "divide",
            "target",
            "sdf-target",
            "function-target",
            "node-target",
            "position",
            "acceleration",
            "kinetic",
            "stress",
            "stress_norm",
            "max_stress",
            "compliance",
            "strain_norm",
            "boundary_smoothing",
            "collision_barrier",
            "control_smoothing",
            "material_smoothing",
            "volume",
            "soft_constraint",
            "layer_thickness",
            "AMIPS"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/power",
        "type": "float",
        "default": 2,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/adjust_weight_period",
        "type": "int",
        "default": 1000000,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/adjustment_coeff",
        "type": "float",
        "default": 1.0,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/scale_invariant",
        "type": "bool",
        "default": true,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "divide",
        "required": [
            "objective"
        ],
        "optional": [
            "weight"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "power",
        "required": [
            "type"
        ],
        "optional": [
            "power",
            "weight"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "sdf-target",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "control_points",
            "control_points_grid",
            "knots",
            "knots_u",
            "knots_v",
            "delta",
            "weight",
            "surface_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "node-target",
        "required": [
            "state",
            "type",
            "targets",
            "node_ids"
        ],
        "optional": [
            "weight"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "function-target",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "weight",
            "target_function",
            "target_function_gradient",
            "surface_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "target",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "weight",
            "surface_selection",
            "reference_cached_body_ids",
            "target_state"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/volume_selection",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/volume_selection",
        "type": "file",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/volume_selection/*",
        "type": "int",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/surface_selection",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/surface_selection/*",
        "type": "int",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/reference_cached_body_ids",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/reference_cached_body_ids/*",
        "type": "int",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/target_state",
        "type": "int",
        "default": -1,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/weight",
        "type": "float",
        "default": 1,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/integral_type",
        "type": "string",
        "default": "uniform",
        "options": [
            "simpson",
            "uniform",
            "final",
            "steps"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/steps",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/target_function",
        "type": "string",
        "default": "0",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/target_function_gradient",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/target_function_gradient/*",
        "type": "string",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/target_displacement",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/target_displacement/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/active_dimension",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/active_dimension/*",
        "type": "bool",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/control_points",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/control_points/*",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/control_points/*/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/knots",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/knots/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/control_points_grid",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/control_points_grid/*",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/control_points_grid/*/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/knots_u",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/knots_u/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/knots_v",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/knots_v/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/delta",
        "type": "list",
        "default": [],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/delta/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/state",
        "type": "int",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/matching",
        "type": "string",
        "options": [
            "exact",
            "marker-data",
            "exact-marker"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "position",
        "required": [
            "state",
            "type",
            "dim"
        ],
        "optional": [
            "weight",
            "volume_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "soft_constraint",
        "required": [
            "objective",
            "soft_bound"
        ],
        "optional": [
            "weight",
            "power"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/objective",
        "type": "object",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/objective",
        "type": "list",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/objective/*",
        "type": "object",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "transient_integral",
        "required": [
            "static_objective",
            "state"
        ],
        "optional": [
            "weight",
            "integral_type",
            "steps"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/static_objective",
        "type": "object",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "acceleration",
        "required": [
            "state",
            "type",
            "dim"
        ],
        "optional": [
            "weight",
            "volume_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "kinetic",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "weight",
            "volume_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "stress",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "volume_selection",
            "weight",
            "dimensions"
        ],
        "doc": "One entry of elastic stress matrix"
    },
    {
        "pointer": "/functionals/*/dimensions",
        "default": [],
        "type": "list"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "stress_norm",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "volume_selection",
            "power",
            "weight"
        ],
        "doc": "Lp Norm of elastic stress over the volume selection"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "max_stress",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "volume_selection",
            "weight"
        ],
        "doc": "Pointwise max stress over the volume selection"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "compliance",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "volume_selection",
            "weight"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "strain_norm",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "volume_selection",
            "weight"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/bounds",
        "type": "list",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/bounds/*",
        "type": "object",
        "required": [
            "min",
            "max",
            "type",
            "dhat",
            "kappa"
        ],
        "doc": "Barrier function parameters for material bounds."
    },
    {
        "pointer": "/functionals/*/bounds/*/type",
        "type": "string",
        "options": [
            "E",
            "nu",
            "lambda",
            "mu"
        ]
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "boundary_smoothing",
        "required": [
            "type"
        ],
        "optional": [
            "scale_invariant",
            "power",
            "weight",
            "adjust_weight_period",
            "adjustment_coeff",
            "surface_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "material_smoothing",
        "required": [
            "type"
        ],
        "optional": [
            "weight",
            "volume_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "control_smoothing",
        "required": [
            "state",
            "type"
        ],
        "optional": [
            "weight"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "collision_barrier",
        "optional": [
            "weight",
            "dhat"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "layer_thickness",
        "optional": [
            "adjacent_boundary_id",
            "dmin",
            "dhat",
            "weight"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/dhat",
        "type": "float",
        "default": 1e-3,
        "doc": "The support size of barrier function"
    },
    {
        "pointer": "/functionals/*/adjacent_boundary_id",
        "type": "int",
        "default": -1,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/dmin",
        "type": "float",
        "default": 0.0,
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "volume",
        "required": [
            "type",
            "state"
        ],
        "optional": [
            "weight",
            "volume_selection"
        ],
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/soft_bound",
        "type": "list",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*/soft_bound/*",
        "type": "float",
        "doc": "TODO"
    },
    {
        "pointer": "/functionals/*",
        "type": "object",
        "type_name": "AMIPS",
        "required": [
            "type",
            "state"
        ],
        "optional": [
            "volume_selection",
            "weight"
        ],
        "doc": "TODO"
    }
]